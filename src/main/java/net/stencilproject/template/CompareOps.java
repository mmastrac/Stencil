package net.stencilproject.template;

/**
 * AUTOGENERATED: Do not edit!
 * 
 * Handles comparisons between two arbitrary objects in an intelligent (but not
 * too intelligent) manner.
 */
public final class CompareOps {

	public static final int compare(TemplateContext ctx, Object o1, Object o2) {

		if (o1 == null) {

			if (o2 == null) {
				return 0;
			}

			return -1;

		}

		if (Types.isString(ctx, o1)) {

			if (o2 == null) {
				return 1;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			ctx.warn("Unsupported compare operands");
			return 0;

		}

		if (Types.isIntegral(ctx, o1)) {

			if (o2 == null) {
				return 1;
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			ctx.warn("Unsupported compare operands");
			return 0;

		}

		if (Types.isDouble(ctx, o1)) {

			if (o2 == null) {
				return 1;
			}

			if (Types.isIntegral(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			ctx.warn("Unsupported compare operands");
			return 0;

		}

		if (Types.isEnum(ctx, o1)) {

			if (o2 == null) {
				return 1;
			}

			if (Types.isEnum(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2);
			}

			ctx.warn("Unsupported compare operands");
			return 0;

		}

		if (Types.isBoolean(ctx, o1)) {

			if (o2 == null) {
				return 1;
			}

			if (Types.isIntegral(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			if (Types.isDouble(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return internalCompare(ctx, v1, v2);
			}

			ctx.warn("Unsupported compare operands");
			return 0;

		}

		if (Types.isComparable(ctx, o1)) {

			if (o2 == null) {
				return 1;
			}

			if (Types.isComparable(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2);
			}

			ctx.warn("Unsupported compare operands");
			return 0;

		}

		if (o2 == null) {
			return 1;
		}

		ctx.warn("Unsupported compare operands");
		return 0;

	}

	public static final boolean eq(TemplateContext ctx, Object o1, Object o2) {

		if (o1 == null) {

			if (o2 == null) {
				return true;
			}

			return false;

		}

		if (Types.isString(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return v1.equals(v2);
			}

			if (Types.isEnum(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return v1.equals(v2);
			}

			ctx.warn("Unsupported eq operands");
			return false;

		}

		if (Types.isIntegral(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 == v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 == v2;
			}

			if (Types.isEnum(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 == v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 == v2;
			}

			ctx.warn("Unsupported eq operands");
			return false;

		}

		if (Types.isDouble(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 == v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 == v2;
			}

			if (Types.isEnum(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 == v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 == v2;
			}

			ctx.warn("Unsupported eq operands");
			return false;

		}

		if (Types.isEnum(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return v1.equals(v2);
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 == v2;
			}

			if (Types.isDouble(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 == v2;
			}

			if (Types.isEnum(ctx, o2)) {
				return o1 == o2;
			}

			ctx.warn("Unsupported eq operands");
			return false;

		}

		if (Types.isBoolean(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 == v2;
			}

			if (Types.isDouble(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 == v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 == v2;
			}

			ctx.warn("Unsupported eq operands");
			return false;

		}

		if (Types.isComparable(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isComparable(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) == 0;
			}

			return o1 == o2;

		}

		if (o2 == null) {
			return false;
		}

		return o1 == o2;

	}

	public static final boolean gt(TemplateContext ctx, Object o1, Object o2) {

		if (o1 == null) {

			return false;

		}

		if (Types.isString(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return internalCompare(ctx, v1, v2) > 0;
			}

			ctx.warn("Unsupported gt operands");
			return false;

		}

		if (Types.isIntegral(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 > v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 > v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 && !v2;
			}

			ctx.warn("Unsupported gt operands");
			return false;

		}

		if (Types.isDouble(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 > v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 > v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 && !v2;
			}

			ctx.warn("Unsupported gt operands");
			return false;

		}

		if (Types.isEnum(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isEnum(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) > 0;
			}

			ctx.warn("Unsupported gt operands");
			return false;

		}

		if (Types.isBoolean(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 && !v2;
			}

			if (Types.isDouble(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 && !v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 && !v2;
			}

			ctx.warn("Unsupported gt operands");
			return false;

		}

		if (Types.isComparable(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isComparable(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) > 0;
			}

			ctx.warn("Unsupported gt operands");
			return false;

		}

		if (o2 == null) {
			return false;
		}

		ctx.warn("Unsupported gt operands");
		return false;

	}

	public static final boolean gte(TemplateContext ctx, Object o1, Object o2) {

		if (o1 == null) {

			if (o2 == null) {
				return true;
			}

			return false;

		}

		if (Types.isString(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return internalCompare(ctx, v1, v2) >= 0;
			}

			ctx.warn("Unsupported gte operands");
			return false;

		}

		if (Types.isIntegral(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 >= v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 >= v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				return true;
			}

			ctx.warn("Unsupported gte operands");
			return false;

		}

		if (Types.isDouble(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 >= v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 >= v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				return true;
			}

			ctx.warn("Unsupported gte operands");
			return false;

		}

		if (Types.isEnum(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isEnum(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) >= 0;
			}

			ctx.warn("Unsupported gte operands");
			return false;

		}

		if (Types.isBoolean(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isIntegral(ctx, o2)) {
				return true;
			}

			if (Types.isDouble(ctx, o2)) {
				return true;
			}

			if (Types.isBoolean(ctx, o2)) {
				return true;
			}

			ctx.warn("Unsupported gte operands");
			return false;

		}

		if (Types.isComparable(ctx, o1)) {

			if (o2 == null) {
				return false;
			}

			if (Types.isComparable(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) >= 0;
			}

			ctx.warn("Unsupported gte operands");
			return false;

		}

		if (o2 == null) {
			return false;
		}

		ctx.warn("Unsupported gte operands");
		return false;

	}

	public static final boolean lt(TemplateContext ctx, Object o1, Object o2) {

		if (o1 == null) {

			if (o2 == null) {
				return false;
			}

			return true;

		}

		if (Types.isString(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return internalCompare(ctx, v1, v2) < 0;
			}

			ctx.warn("Unsupported lt operands");
			return false;

		}

		if (Types.isIntegral(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 < v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 < v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return !v1 && v2;
			}

			ctx.warn("Unsupported lt operands");
			return false;

		}

		if (Types.isDouble(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 < v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 < v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return !v1 && v2;
			}

			ctx.warn("Unsupported lt operands");
			return false;

		}

		if (Types.isEnum(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isEnum(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) < 0;
			}

			ctx.warn("Unsupported lt operands");
			return false;

		}

		if (Types.isBoolean(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return !v1 && v2;
			}

			if (Types.isDouble(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return !v1 && v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return !v1 && v2;
			}

			ctx.warn("Unsupported lt operands");
			return false;

		}

		if (Types.isComparable(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isComparable(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) < 0;
			}

			ctx.warn("Unsupported lt operands");
			return false;

		}

		if (o2 == null) {
			return true;
		}

		ctx.warn("Unsupported lt operands");
		return false;

	}

	public static final boolean lte(TemplateContext ctx, Object o1, Object o2) {

		if (o1 == null) {

			return true;

		}

		if (Types.isString(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return internalCompare(ctx, v1, v2) <= 0;
			}

			ctx.warn("Unsupported lte operands");
			return false;

		}

		if (Types.isIntegral(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 <= v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 <= v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				return true;
			}

			ctx.warn("Unsupported lte operands");
			return false;

		}

		if (Types.isDouble(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 <= v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 <= v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				return true;
			}

			ctx.warn("Unsupported lte operands");
			return false;

		}

		if (Types.isEnum(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isEnum(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) <= 0;
			}

			ctx.warn("Unsupported lte operands");
			return false;

		}

		if (Types.isBoolean(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				return true;
			}

			if (Types.isDouble(ctx, o2)) {
				return true;
			}

			if (Types.isBoolean(ctx, o2)) {
				return true;
			}

			ctx.warn("Unsupported lte operands");
			return false;

		}

		if (Types.isComparable(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isComparable(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) <= 0;
			}

			ctx.warn("Unsupported lte operands");
			return false;

		}

		if (o2 == null) {
			return true;
		}

		ctx.warn("Unsupported lte operands");
		return false;

	}

	public static final boolean neq(TemplateContext ctx, Object o1, Object o2) {

		if (o1 == null) {

			if (o2 == null) {
				return false;
			}

			return true;

		}

		if (Types.isString(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return !v1.equals(v2);
			}

			if (Types.isEnum(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return !v1.equals(v2);
			}

			ctx.warn("Unsupported neq operands");
			return false;

		}

		if (Types.isIntegral(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 != v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 != v2;
			}

			if (Types.isEnum(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 != v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 != v2;
			}

			ctx.warn("Unsupported neq operands");
			return false;

		}

		if (Types.isDouble(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 != v2;
			}

			if (Types.isDouble(ctx, o2)) {
				double v1 = Types.toDouble(ctx, o1);
				double v2 = Types.toDouble(ctx, o2);
				return v1 != v2;
			}

			if (Types.isEnum(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 != v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 != v2;
			}

			ctx.warn("Unsupported neq operands");
			return false;

		}

		if (Types.isEnum(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isString(ctx, o2)) {
				String v1 = Types.toString(ctx, o1);
				String v2 = Types.toString(ctx, o2);
				return !v1.equals(v2);
			}

			if (Types.isIntegral(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 != v2;
			}

			if (Types.isDouble(ctx, o2)) {
				long v1 = Types.toLong(ctx, o1);
				long v2 = Types.toLong(ctx, o2);
				return v1 != v2;
			}

			if (Types.isEnum(ctx, o2)) {
				return o1 != o2;
			}

			ctx.warn("Unsupported neq operands");
			return false;

		}

		if (Types.isBoolean(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isIntegral(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 != v2;
			}

			if (Types.isDouble(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 != v2;
			}

			if (Types.isBoolean(ctx, o2)) {
				boolean v1 = Types.toBoolean(ctx, o1);
				boolean v2 = Types.toBoolean(ctx, o2);
				return v1 != v2;
			}

			ctx.warn("Unsupported neq operands");
			return false;

		}

		if (Types.isComparable(ctx, o1)) {

			if (o2 == null) {
				return true;
			}

			if (Types.isComparable(ctx, o2)) {
				Comparable<?> v1 = (Comparable<?>) o1;
				Comparable<?> v2 = (Comparable<?>) o2;
				return internalCompare(ctx, v1, v2) != 0;
			}

			return o1 != o2;

		}

		if (o2 == null) {
			return true;
		}

		return o1 != o2;

	}

	private static final int internalCompare(TemplateContext ctx, String s1, String s2) {
		return s1.compareTo(s2);
	}

	private static final int internalCompare(TemplateContext ctx, long l1, long l2) {
		return (l1 < l2) ? -1 : ((l1 == l2) ? 0 : 1);
	}

	private static final int internalCompare(TemplateContext ctx, double d1, double d2) {
		return Double.compare(d1, d2);
	}

	private static final int internalCompare(TemplateContext ctx, boolean b1, boolean b2) {
		return (b1 == b2) ? 0 : (b1 ? 1 : -1);
	}

	private static final int internalCompare(TemplateContext ctx, Comparable<?> value1, Comparable<?> value2) {
		Class<? extends Object> c1 = value1.getClass();
		Class<? extends Object> c2 = value2.getClass();

		if (c1 == c2 || c1.isInstance(value2)) {
			@SuppressWarnings("unchecked")
			Comparable<Object> v1 = (Comparable<Object>) value1;
			return v1.compareTo(value2);
		} else if (c2.isInstance(value1)) {
			@SuppressWarnings("unchecked")
			Comparable<Object> v2 = (Comparable<Object>) value2;
			return -v2.compareTo(value1);
		} else {
			ctx.warn("Incompatible and undefined comparison: " + c1 + " to " + c2);
			return 0;
		}
	}
}
